// Generated by `wit-bindgen` 0.39.0. DO NOT EDIT!
// <auto-generated />
#nullable enable

using System;
using System.Runtime.InteropServices;

namespace ImportsWorld.wit.imports.wasi.sockets.v0_2_1;

public interface ITcp {

    public enum ShutdownType {
        RECEIVE, SEND, BOTH
    }

    /**
    * A TCP socket resource.
    *
    * The socket can be in one of the following states:
    * - `unbound`
    * - `bind-in-progress`
    * - `bound` (See note below)
    * - `listen-in-progress`
    * - `listening`
    * - `connect-in-progress`
    * - `connected`
    * - `closed`
    * See &lt;https://github.com/WebAssembly/wasi-sockets/blob/main/TcpSocketOperationalSemantics.md&gt;
    * for more information.
    *
    * Note: Except where explicitly mentioned, whenever this documentation uses
    * the term "bound" without backticks it actually means: in the `bound` state *or higher*.
    * (i.e. `bound`, `listen-in-progress`, `listening`, `connect-in-progress` or `connected`)
    *
    * In addition to the general error codes documented on the
    * `network::error-code` type, TCP socket methods may always return
    * `error(invalid-state)` when in the `closed` state.
    */

    public class TcpSocket: IDisposable {
        internal int Handle { get; set; }

        public readonly record struct THandle(int Handle);

        public TcpSocket(THandle handle) {
            Handle = handle.Handle;
        }

        public void Dispose() {
            Dispose(true);
        }

        [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[resource-drop]tcp-socket"), WasmImportLinkage]
        private static extern void wasmImportResourceDrop(int p0);

        protected virtual void Dispose(bool disposing) {
            if (disposing && Handle != 0) {
                wasmImportResourceDrop(Handle);
                Handle = 0;
            }
        }

        internal static class StartBindWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.start-bind"), WasmImportLinkage]
            internal static extern void wasmImportStartBind(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9, int p10, int p11, int p12, int p13, nint p14);
        }

        public   unsafe void StartBind(global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Network network, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress localAddress)
        {
            var handle = this.Handle;
            var handle0 = network.Handle;

            int lowered;
            int lowered4;
            int lowered5;
            int lowered6;
            int lowered7;
            int lowered8;
            int lowered9;
            int lowered10;
            int lowered11;
            int lowered12;
            int lowered13;
            int lowered14;

            switch (localAddress.Tag) {
                case 0: {
                    global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv4SocketAddress payload = localAddress.AsIpv4;

                    lowered = 0;
                    lowered4 = payload.port;
                    lowered5 = payload.address.Item1;
                    lowered6 = payload.address.Item2;
                    lowered7 = payload.address.Item3;
                    lowered8 = payload.address.Item4;
                    lowered9 = 0;
                    lowered10 = 0;
                    lowered11 = 0;
                    lowered12 = 0;
                    lowered13 = 0;
                    lowered14 = 0;

                    break;
                }
                case 1: {
                    global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv6SocketAddress payload3 = localAddress.AsIpv6;

                    lowered = 1;
                    lowered4 = payload3.port;
                    lowered5 = unchecked((int)(payload3.flowInfo));
                    lowered6 = payload3.address.Item1;
                    lowered7 = payload3.address.Item2;
                    lowered8 = payload3.address.Item3;
                    lowered9 = payload3.address.Item4;
                    lowered10 = payload3.address.Item5;
                    lowered11 = payload3.address.Item6;
                    lowered12 = payload3.address.Item7;
                    lowered13 = payload3.address.Item8;
                    lowered14 = unchecked((int)(payload3.scopeId));

                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {localAddress}");
            }

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            StartBindWasmInterop.wasmImportStartBind(handle, handle0, lowered, lowered4, lowered5, lowered6, lowered7, lowered8, lowered9, lowered10, lowered11, lowered12, lowered13, lowered14, ptr);

            Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(new global::ImportsWorld.None());
                    break;
                }
                case 1: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return ;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class FinishBindWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.finish-bind"), WasmImportLinkage]
            internal static extern void wasmImportFinishBind(int p0, nint p1);
        }

        public   unsafe void FinishBind()
        {
            var handle = this.Handle;

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            FinishBindWasmInterop.wasmImportFinishBind(handle, ptr);

            Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(new global::ImportsWorld.None());
                    break;
                }
                case 1: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return ;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class StartConnectWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.start-connect"), WasmImportLinkage]
            internal static extern void wasmImportStartConnect(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9, int p10, int p11, int p12, int p13, nint p14);
        }

        public   unsafe void StartConnect(global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Network network, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress remoteAddress)
        {
            var handle = this.Handle;
            var handle0 = network.Handle;

            int lowered;
            int lowered4;
            int lowered5;
            int lowered6;
            int lowered7;
            int lowered8;
            int lowered9;
            int lowered10;
            int lowered11;
            int lowered12;
            int lowered13;
            int lowered14;

            switch (remoteAddress.Tag) {
                case 0: {
                    global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv4SocketAddress payload = remoteAddress.AsIpv4;

                    lowered = 0;
                    lowered4 = payload.port;
                    lowered5 = payload.address.Item1;
                    lowered6 = payload.address.Item2;
                    lowered7 = payload.address.Item3;
                    lowered8 = payload.address.Item4;
                    lowered9 = 0;
                    lowered10 = 0;
                    lowered11 = 0;
                    lowered12 = 0;
                    lowered13 = 0;
                    lowered14 = 0;

                    break;
                }
                case 1: {
                    global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv6SocketAddress payload3 = remoteAddress.AsIpv6;

                    lowered = 1;
                    lowered4 = payload3.port;
                    lowered5 = unchecked((int)(payload3.flowInfo));
                    lowered6 = payload3.address.Item1;
                    lowered7 = payload3.address.Item2;
                    lowered8 = payload3.address.Item3;
                    lowered9 = payload3.address.Item4;
                    lowered10 = payload3.address.Item5;
                    lowered11 = payload3.address.Item6;
                    lowered12 = payload3.address.Item7;
                    lowered13 = payload3.address.Item8;
                    lowered14 = unchecked((int)(payload3.scopeId));

                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {remoteAddress}");
            }

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            StartConnectWasmInterop.wasmImportStartConnect(handle, handle0, lowered, lowered4, lowered5, lowered6, lowered7, lowered8, lowered9, lowered10, lowered11, lowered12, lowered13, lowered14, ptr);

            Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(new global::ImportsWorld.None());
                    break;
                }
                case 1: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return ;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class FinishConnectWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.finish-connect"), WasmImportLinkage]
            internal static extern void wasmImportFinishConnect(int p0, nint p1);
        }

        public   unsafe (global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.InputStream, global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.OutputStream) FinishConnect()
        {
            var handle = this.Handle;

            var retArea = stackalloc uint[3+1];
            var ptr = ((int)retArea) + (4 - 1) & -4;
            FinishConnectWasmInterop.wasmImportFinishConnect(handle, ptr);

            Result<(global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.InputStream, global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.OutputStream), global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {
                    var resource = new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.InputStream(new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.InputStream.THandle(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4))));
                    var resource0 = new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.OutputStream(new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.OutputStream.THandle(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4))));

                    lifted = Result<(global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.InputStream, global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.OutputStream), global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok((resource, resource0));
                    break;
                }
                case 1: {

                    lifted = Result<(global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.InputStream, global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.OutputStream), global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 4), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return tmp;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class StartListenWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.start-listen"), WasmImportLinkage]
            internal static extern void wasmImportStartListen(int p0, nint p1);
        }

        public   unsafe void StartListen()
        {
            var handle = this.Handle;

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            StartListenWasmInterop.wasmImportStartListen(handle, ptr);

            Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(new global::ImportsWorld.None());
                    break;
                }
                case 1: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return ;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class FinishListenWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.finish-listen"), WasmImportLinkage]
            internal static extern void wasmImportFinishListen(int p0, nint p1);
        }

        public   unsafe void FinishListen()
        {
            var handle = this.Handle;

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            FinishListenWasmInterop.wasmImportFinishListen(handle, ptr);

            Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(new global::ImportsWorld.None());
                    break;
                }
                case 1: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return ;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class AcceptWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.accept"), WasmImportLinkage]
            internal static extern void wasmImportAccept(int p0, nint p1);
        }

        public   unsafe (global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.ITcp.TcpSocket, global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.InputStream, global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.OutputStream) Accept()
        {
            var handle = this.Handle;

            var retArea = stackalloc uint[4+1];
            var ptr = ((int)retArea) + (4 - 1) & -4;
            AcceptWasmInterop.wasmImportAccept(handle, ptr);

            Result<(global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.ITcp.TcpSocket, global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.InputStream, global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.OutputStream), global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {
                    var resource = new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.ITcp.TcpSocket(new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.ITcp.TcpSocket.THandle(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4))));
                    var resource0 = new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.InputStream(new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.InputStream.THandle(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4))));
                    var resource1 = new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.OutputStream(new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.OutputStream.THandle(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));

                    lifted = Result<(global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.ITcp.TcpSocket, global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.InputStream, global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.OutputStream), global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok((resource, resource0, resource1));
                    break;
                }
                case 1: {

                    lifted = Result<(global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.ITcp.TcpSocket, global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.InputStream, global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IStreams.OutputStream), global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 4), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return tmp;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class LocalAddressWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.local-address"), WasmImportLinkage]
            internal static extern void wasmImportLocalAddress(int p0, nint p1);
        }

        public   unsafe global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress LocalAddress()
        {
            var handle = this.Handle;

            var retArea = stackalloc uint[9+1];
            var ptr = ((int)retArea) + (4 - 1) & -4;
            LocalAddressWasmInterop.wasmImportLocalAddress(handle, ptr);

            Result<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted6;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress lifted;

                    switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                        case 0: {

                            lifted = global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress.Ipv4(new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv4SocketAddress (
                            ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 8), 2))), (((byte)new Span<byte>((void*)(ptr + 10), 1)[0]), ((byte)new Span<byte>((void*)(ptr + 11), 1)[0]), ((byte)new Span<byte>((void*)(ptr + 12), 1)[0]), ((byte)new Span<byte>((void*)(ptr + 13), 1)[0]))));
                            break;
                        }
                        case 1: {

                            lifted = global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress.Ipv6(new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv6SocketAddress (
                            ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 8), 2))), unchecked((uint)(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4)))), (((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 16), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 18), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 20), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 22), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 24), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 26), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 28), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 30), 2)))), unchecked((uint)(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 32), 4))))));
                            break;
                        }

                        default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                    }

                    lifted6 = Result<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(lifted);
                    break;
                }
                case 1: {

                    lifted6 = Result<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 4), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted6.IsOk)
            {
                var tmp = lifted6.AsOk;
                return tmp;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted6.AsErr!, 0);
            }

        }

        internal static class RemoteAddressWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.remote-address"), WasmImportLinkage]
            internal static extern void wasmImportRemoteAddress(int p0, nint p1);
        }

        public   unsafe global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress RemoteAddress()
        {
            var handle = this.Handle;

            var retArea = stackalloc uint[9+1];
            var ptr = ((int)retArea) + (4 - 1) & -4;
            RemoteAddressWasmInterop.wasmImportRemoteAddress(handle, ptr);

            Result<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted6;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress lifted;

                    switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                        case 0: {

                            lifted = global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress.Ipv4(new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv4SocketAddress (
                            ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 8), 2))), (((byte)new Span<byte>((void*)(ptr + 10), 1)[0]), ((byte)new Span<byte>((void*)(ptr + 11), 1)[0]), ((byte)new Span<byte>((void*)(ptr + 12), 1)[0]), ((byte)new Span<byte>((void*)(ptr + 13), 1)[0]))));
                            break;
                        }
                        case 1: {

                            lifted = global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress.Ipv6(new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv6SocketAddress (
                            ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 8), 2))), unchecked((uint)(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4)))), (((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 16), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 18), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 20), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 22), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 24), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 26), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 28), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 30), 2)))), unchecked((uint)(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 32), 4))))));
                            break;
                        }

                        default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                    }

                    lifted6 = Result<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(lifted);
                    break;
                }
                case 1: {

                    lifted6 = Result<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 4), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted6.IsOk)
            {
                var tmp = lifted6.AsOk;
                return tmp;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted6.AsErr!, 0);
            }

        }

        internal static class IsListeningWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.is-listening"), WasmImportLinkage]
            internal static extern int wasmImportIsListening(int p0);
        }

        public   unsafe bool IsListening()
        {
            var handle = this.Handle;
            var result =  IsListeningWasmInterop.wasmImportIsListening(handle);
            return (result != 0);

        }

        internal static class AddressFamilyWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.address-family"), WasmImportLinkage]
            internal static extern int wasmImportAddressFamily(int p0);
        }

        public   unsafe global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpAddressFamily AddressFamily()
        {
            var handle = this.Handle;
            var result =  AddressFamilyWasmInterop.wasmImportAddressFamily(handle);
            return (global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpAddressFamily)result;

        }

        internal static class SetListenBacklogSizeWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.set-listen-backlog-size"), WasmImportLinkage]
            internal static extern void wasmImportSetListenBacklogSize(int p0, long p1, nint p2);
        }

        public   unsafe void SetListenBacklogSize(ulong value)
        {
            var handle = this.Handle;

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            SetListenBacklogSizeWasmInterop.wasmImportSetListenBacklogSize(handle, unchecked((long)(value)), ptr);

            Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(new global::ImportsWorld.None());
                    break;
                }
                case 1: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return ;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class KeepAliveEnabledWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.keep-alive-enabled"), WasmImportLinkage]
            internal static extern void wasmImportKeepAliveEnabled(int p0, nint p1);
        }

        public   unsafe bool KeepAliveEnabled()
        {
            var handle = this.Handle;

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            KeepAliveEnabledWasmInterop.wasmImportKeepAliveEnabled(handle, ptr);

            Result<bool, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<bool, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok((new Span<byte>((void*)(ptr + 1), 1)[0] != 0));
                    break;
                }
                case 1: {

                    lifted = Result<bool, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return tmp;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class SetKeepAliveEnabledWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.set-keep-alive-enabled"), WasmImportLinkage]
            internal static extern void wasmImportSetKeepAliveEnabled(int p0, int p1, nint p2);
        }

        public   unsafe void SetKeepAliveEnabled(bool value)
        {
            var handle = this.Handle;

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            SetKeepAliveEnabledWasmInterop.wasmImportSetKeepAliveEnabled(handle, (value ? 1 : 0), ptr);

            Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(new global::ImportsWorld.None());
                    break;
                }
                case 1: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return ;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class KeepAliveIdleTimeWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.keep-alive-idle-time"), WasmImportLinkage]
            internal static extern void wasmImportKeepAliveIdleTime(int p0, nint p1);
        }

        public   unsafe ulong KeepAliveIdleTime()
        {
            var handle = this.Handle;

            var retArea = stackalloc ulong[2+1];
            var ptr = ((int)retArea) + (8 - 1) & -8;
            KeepAliveIdleTimeWasmInterop.wasmImportKeepAliveIdleTime(handle, ptr);

            Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(unchecked((ulong)(BitConverter.ToInt64(new Span<byte>((void*)(ptr + 8), 8)))));
                    break;
                }
                case 1: {

                    lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 8), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return tmp;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class SetKeepAliveIdleTimeWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.set-keep-alive-idle-time"), WasmImportLinkage]
            internal static extern void wasmImportSetKeepAliveIdleTime(int p0, long p1, nint p2);
        }

        public   unsafe void SetKeepAliveIdleTime(ulong value)
        {
            var handle = this.Handle;

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            SetKeepAliveIdleTimeWasmInterop.wasmImportSetKeepAliveIdleTime(handle, unchecked((long)(value)), ptr);

            Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(new global::ImportsWorld.None());
                    break;
                }
                case 1: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return ;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class KeepAliveIntervalWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.keep-alive-interval"), WasmImportLinkage]
            internal static extern void wasmImportKeepAliveInterval(int p0, nint p1);
        }

        public   unsafe ulong KeepAliveInterval()
        {
            var handle = this.Handle;

            var retArea = stackalloc ulong[2+1];
            var ptr = ((int)retArea) + (8 - 1) & -8;
            KeepAliveIntervalWasmInterop.wasmImportKeepAliveInterval(handle, ptr);

            Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(unchecked((ulong)(BitConverter.ToInt64(new Span<byte>((void*)(ptr + 8), 8)))));
                    break;
                }
                case 1: {

                    lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 8), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return tmp;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class SetKeepAliveIntervalWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.set-keep-alive-interval"), WasmImportLinkage]
            internal static extern void wasmImportSetKeepAliveInterval(int p0, long p1, nint p2);
        }

        public   unsafe void SetKeepAliveInterval(ulong value)
        {
            var handle = this.Handle;

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            SetKeepAliveIntervalWasmInterop.wasmImportSetKeepAliveInterval(handle, unchecked((long)(value)), ptr);

            Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(new global::ImportsWorld.None());
                    break;
                }
                case 1: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return ;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class KeepAliveCountWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.keep-alive-count"), WasmImportLinkage]
            internal static extern void wasmImportKeepAliveCount(int p0, nint p1);
        }

        public   unsafe uint KeepAliveCount()
        {
            var handle = this.Handle;

            var retArea = stackalloc uint[2+1];
            var ptr = ((int)retArea) + (4 - 1) & -4;
            KeepAliveCountWasmInterop.wasmImportKeepAliveCount(handle, ptr);

            Result<uint, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<uint, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(unchecked((uint)(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4)))));
                    break;
                }
                case 1: {

                    lifted = Result<uint, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 4), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return tmp;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class SetKeepAliveCountWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.set-keep-alive-count"), WasmImportLinkage]
            internal static extern void wasmImportSetKeepAliveCount(int p0, int p1, nint p2);
        }

        public   unsafe void SetKeepAliveCount(uint value)
        {
            var handle = this.Handle;

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            SetKeepAliveCountWasmInterop.wasmImportSetKeepAliveCount(handle, unchecked((int)(value)), ptr);

            Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(new global::ImportsWorld.None());
                    break;
                }
                case 1: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return ;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class HopLimitWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.hop-limit"), WasmImportLinkage]
            internal static extern void wasmImportHopLimit(int p0, nint p1);
        }

        public   unsafe byte HopLimit()
        {
            var handle = this.Handle;

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            HopLimitWasmInterop.wasmImportHopLimit(handle, ptr);

            Result<byte, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<byte, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(((byte)new Span<byte>((void*)(ptr + 1), 1)[0]));
                    break;
                }
                case 1: {

                    lifted = Result<byte, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return tmp;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class SetHopLimitWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.set-hop-limit"), WasmImportLinkage]
            internal static extern void wasmImportSetHopLimit(int p0, int p1, nint p2);
        }

        public   unsafe void SetHopLimit(byte value)
        {
            var handle = this.Handle;

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            SetHopLimitWasmInterop.wasmImportSetHopLimit(handle, value, ptr);

            Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(new global::ImportsWorld.None());
                    break;
                }
                case 1: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return ;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class ReceiveBufferSizeWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.receive-buffer-size"), WasmImportLinkage]
            internal static extern void wasmImportReceiveBufferSize(int p0, nint p1);
        }

        public   unsafe ulong ReceiveBufferSize()
        {
            var handle = this.Handle;

            var retArea = stackalloc ulong[2+1];
            var ptr = ((int)retArea) + (8 - 1) & -8;
            ReceiveBufferSizeWasmInterop.wasmImportReceiveBufferSize(handle, ptr);

            Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(unchecked((ulong)(BitConverter.ToInt64(new Span<byte>((void*)(ptr + 8), 8)))));
                    break;
                }
                case 1: {

                    lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 8), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return tmp;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class SetReceiveBufferSizeWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.set-receive-buffer-size"), WasmImportLinkage]
            internal static extern void wasmImportSetReceiveBufferSize(int p0, long p1, nint p2);
        }

        public   unsafe void SetReceiveBufferSize(ulong value)
        {
            var handle = this.Handle;

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            SetReceiveBufferSizeWasmInterop.wasmImportSetReceiveBufferSize(handle, unchecked((long)(value)), ptr);

            Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(new global::ImportsWorld.None());
                    break;
                }
                case 1: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return ;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class SendBufferSizeWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.send-buffer-size"), WasmImportLinkage]
            internal static extern void wasmImportSendBufferSize(int p0, nint p1);
        }

        public   unsafe ulong SendBufferSize()
        {
            var handle = this.Handle;

            var retArea = stackalloc ulong[2+1];
            var ptr = ((int)retArea) + (8 - 1) & -8;
            SendBufferSizeWasmInterop.wasmImportSendBufferSize(handle, ptr);

            Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(unchecked((ulong)(BitConverter.ToInt64(new Span<byte>((void*)(ptr + 8), 8)))));
                    break;
                }
                case 1: {

                    lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 8), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return tmp;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class SetSendBufferSizeWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.set-send-buffer-size"), WasmImportLinkage]
            internal static extern void wasmImportSetSendBufferSize(int p0, long p1, nint p2);
        }

        public   unsafe void SetSendBufferSize(ulong value)
        {
            var handle = this.Handle;

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            SetSendBufferSizeWasmInterop.wasmImportSetSendBufferSize(handle, unchecked((long)(value)), ptr);

            Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(new global::ImportsWorld.None());
                    break;
                }
                case 1: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return ;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

        internal static class SubscribeWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.subscribe"), WasmImportLinkage]
            internal static extern int wasmImportSubscribe(int p0);
        }

        public   unsafe global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IPoll.Pollable Subscribe()
        {
            var handle = this.Handle;
            var result =  SubscribeWasmInterop.wasmImportSubscribe(handle);
            var resource = new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IPoll.Pollable(new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IPoll.Pollable.THandle(result));
            return resource;

        }

        internal static class ShutdownWasmInterop
        {
            [DllImport("wasi:sockets/tcp@0.2.1", EntryPoint = "[method]tcp-socket.shutdown"), WasmImportLinkage]
            internal static extern void wasmImportShutdown(int p0, int p1, nint p2);
        }

        public   unsafe void Shutdown(global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.ITcp.ShutdownType shutdownType)
        {
            var handle = this.Handle;

            var retArea = stackalloc byte[2+1];
            var ptr = ((int)retArea) + (1 - 1) & -1;
            ShutdownWasmInterop.wasmImportShutdown(handle, (int)shutdownType, ptr);

            Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

            switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                case 0: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Ok(new global::ImportsWorld.None());
                    break;
                }
                case 1: {

                    lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.Err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
            }
            if (lifted.IsOk)
            {
                var tmp = lifted.AsOk;
                return ;
            }
            else
            {
                throw new WitException<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>(lifted.AsErr!, 0);
            }

        }

    }

}
